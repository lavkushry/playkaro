package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"time"

	"github.com/playkaro/backend/graph/model"
	"github.com/playkaro/backend/internal/auth"
	"github.com/playkaro/backend/internal/db"
	"github.com/playkaro/backend/internal/models"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var user models.User
	var id string
	var kycLevel int

	// Fetch user from DB
	err := db.DB.QueryRow("SELECT id, username, email, mobile, password_hash, COALESCE(kyc_level, 0) FROM users WHERE email=$1", email).
		Scan(&id, &user.Username, &user.Email, &user.Mobile, &user.PasswordHash, &kycLevel)

	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	// Check password
	if !user.CheckPassword(password) {
		return nil, errors.New("invalid credentials")
	}

	// Generate Token
	token, err := auth.GenerateToken(id)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User:  &model.User{
			ID:       id,
			Username: user.Username,
			Email:    user.Email,
			Mobile:   &user.Mobile,
			KycLevel: kycLevel,
		},
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string, mobile string) (*model.AuthPayload, error) {
	user := models.User{
		Username: username,
		Email:    email,
		Mobile:   mobile,
	}

	if err := user.SetPassword(password); err != nil {
		return nil, err
	}

	var id string
	err := db.DB.QueryRow(
		"INSERT INTO users (username, email, password_hash, mobile) VALUES ($1, $2, $3, $4) RETURNING id",
		user.Username, user.Email, user.PasswordHash, user.Mobile,
	).Scan(&id)

	if err != nil {
		return nil, errors.New("email already exists")
	}

	// Create wallet
	db.DB.Exec("INSERT INTO wallets (user_id, currency) VALUES ($1, 'INR')", id)

	token, _ := auth.GenerateToken(id)

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:       id,
			Username: username,
			Email:    email,
			Mobile:   &mobile,
			KycLevel: 0,
		},
	}, nil
}

// PlaceBet is the resolver for the placeBet field.
func (r *mutationResolver) PlaceBet(ctx context.Context, matchID string, selection string, amount float64) (bool, error) {
	// In a real implementation, you'd get the User ID from context (middleware)
	// For PoC, we'll assume a fixed user or skip auth check in resolver
	// This requires context-based auth which is advanced setup
	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Requires Auth Middleware to populate context
	return nil, nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context) (*model.Wallet, error) {
	return nil, nil
}

// Matches is the resolver for the matches field.
func (r *queryResolver) Matches(ctx context.Context) ([]*model.Match, error) {
	rows, err := db.DB.Query("SELECT id, team_a, team_b, start_time, status, odds_a, odds_b FROM matches")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var matches []*model.Match
	for rows.Next() {
		var m model.Match
		var t time.Time
		// We don't have odds_draw in DB yet, so we'll skip it or set to 0
		rows.Scan(&m.ID, &m.TeamA, &m.TeamB, &t, &m.Status, &m.OddsTeamA, &m.OddsTeamB)
		m.StartTime = t.String()
		m.OddsDraw = 0 // Default
		matches = append(matches, &m)
	}
	return matches, nil
}

// Match is the resolver for the match field.
func (r *queryResolver) Match(ctx context.Context, id string) (*model.Match, error) {
	var m model.Match
	var t time.Time
	err := db.DB.QueryRow("SELECT id, team_a, team_b, start_time, status, odds_a, odds_b FROM matches WHERE id=$1", id).
		Scan(&m.ID, &m.TeamA, &m.TeamB, &t, &m.Status, &m.OddsTeamA, &m.OddsTeamB)
	if err != nil {
		return nil, err
	}
	m.StartTime = t.String()
	m.OddsDraw = 0
	return &m, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
