package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"time"

	"github.com/playkaro/backend/graph/model"
	"github.com/playkaro/backend/internal/auth"
	"github.com/playkaro/backend/internal/db"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var user model.User
	var storedPassword string
	var id string
	var kycLevel int

	err := db.DB.QueryRow("SELECT id, username, email, mobile, password, COALESCE(kyc_level, 0) FROM users WHERE email=$1", email).
		Scan(&id, &user.Username, &user.Email, &user.Mobile, &storedPassword, &kycLevel)

	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	if !auth.CheckPasswordHash(password, storedPassword) {
		return nil, errors.New("invalid credentials")
	}

	user.ID = id
	user.KycLevel = kycLevel

	token, err := auth.GenerateJWT(id)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User:  &user,
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string, mobile string) (*model.AuthPayload, error) {
	hashedPassword, _ := auth.HashPassword(password)
	var id string

	err := db.DB.QueryRow(
		"INSERT INTO users (username, email, password, mobile) VALUES ($1, $2, $3, $4) RETURNING id",
		username, email, hashedPassword, mobile,
	).Scan(&id)

	if err != nil {
		return nil, errors.New("email already exists")
	}

	// Create wallet
	db.DB.Exec("INSERT INTO wallets (user_id, balance, currency) VALUES ($1, 0, 'INR')", id)

	token, _ := auth.GenerateJWT(id)

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:       id,
			Username: username,
			Email:    email,
			Mobile:   &mobile,
			KycLevel: 0,
		},
	}, nil
}

// PlaceBet is the resolver for the placeBet field.
func (r *mutationResolver) PlaceBet(ctx context.Context, matchID string, selection string, amount float64) (bool, error) {
	// In a real implementation, you'd get the User ID from context (middleware)
	// For PoC, we'll assume a fixed user or skip auth check in resolver
	// This requires context-based auth which is advanced setup
	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	// Requires Auth Middleware to populate context
	return nil, nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context) (*model.Wallet, error) {
	return nil, nil
}

// Matches is the resolver for the matches field.
func (r *queryResolver) Matches(ctx context.Context) ([]*model.Match, error) {
	rows, err := db.DB.Query("SELECT id, team_a, team_b, start_time, status, odds_team_a, odds_team_b, odds_draw FROM matches")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var matches []*model.Match
	for rows.Next() {
		var m model.Match
		var t time.Time
		rows.Scan(&m.ID, &m.TeamA, &m.TeamB, &t, &m.Status, &m.OddsTeamA, &m.OddsTeamB, &m.OddsDraw)
		m.StartTime = t.String()
		matches = append(matches, &m)
	}
	return matches, nil
}

// Match is the resolver for the match field.
func (r *queryResolver) Match(ctx context.Context, id string) (*model.Match, error) {
	var m model.Match
	var t time.Time
	err := db.DB.QueryRow("SELECT id, team_a, team_b, start_time, status, odds_team_a, odds_team_b, odds_draw FROM matches WHERE id=$1", id).
		Scan(&m.ID, &m.TeamA, &m.TeamB, &t, &m.Status, &m.OddsTeamA, &m.OddsTeamB, &m.OddsDraw)
	if err != nil {
		return nil, err
	}
	m.StartTime = t.String()
	return &m, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
