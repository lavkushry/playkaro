package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.83

import (
	"context"
	"errors"
	"time"

	"github.com/playkaro/backend/graph/model"
	"github.com/playkaro/backend/internal/auth"
	"github.com/playkaro/backend/internal/db"
	"github.com/playkaro/backend/internal/models"
	"github.com/playkaro/backend/internal/wallet"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (*model.AuthPayload, error) {
	var user models.User
	var id string
	var kycLevel int

	// Fetch user from DB
	err := db.DB.QueryRow("SELECT id, username, email, mobile, password_hash, COALESCE(kyc_level, 0) FROM users WHERE email=$1", email).
		Scan(&id, &user.Username, &user.Email, &user.Mobile, &user.PasswordHash, &kycLevel)

	if err != nil {
		return nil, errors.New("invalid credentials")
	}

	// Check password
	if !user.CheckPassword(password) {
		return nil, errors.New("invalid credentials")
	}

	// Generate Token
	token, err := auth.GenerateToken(id)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:       id,
			Username: user.Username,
			Email:    user.Email,
			Mobile:   &user.Mobile,
			KycLevel: kycLevel,
		},
	}, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, email string, password string, mobile string) (*model.AuthPayload, error) {
	user := models.User{
		Username: username,
		Email:    email,
		Mobile:   mobile,
	}

	if err := user.SetPassword(password); err != nil {
		return nil, err
	}

	var id string
	err := db.DB.QueryRow(
		"INSERT INTO users (username, email, password_hash, mobile) VALUES ($1, $2, $3, $4) RETURNING id",
		user.Username, user.Email, user.PasswordHash, user.Mobile,
	).Scan(&id)

	if err != nil {
		return nil, errors.New("email already exists")
	}

	// Create wallet
	db.DB.Exec("INSERT INTO wallets (user_id, currency) VALUES ($1, 'INR')", id)

	token, _ := auth.GenerateToken(id)

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:       id,
			Username: username,
			Email:    email,
			Mobile:   &mobile,
			KycLevel: 0,
		},
	}, nil
}

// PlaceBet is the resolver for the placeBet field.
func (r *mutationResolver) PlaceBet(ctx context.Context, matchID string, selection string, amount float64) (bool, error) {
	userID, ok := UserIDFromContext(ctx)
	if !ok {
		return false, errors.New("unauthorized")
	}
	if selection != "TEAM_A" && selection != "TEAM_B" {
		return false, errors.New("invalid selection")
	}
	if amount <= 0 {
		return false, errors.New("amount must be positive")
	}

	svc := wallet.NewService(db.DB, db.RDB)
	lockRef := "BET-" + time.Now().Format("20060102150405")
	if _, err := svc.LockForBet(ctx, userID, amount, lockRef); err != nil {
		return false, err
	}

	tx, err := db.DB.Begin()
	if err != nil {
		svc.SettleBet(ctx, userID, amount, 0, false, lockRef)
		return false, err
	}
	defer tx.Rollback()

	var odds float64
	var oddsA, oddsB float64
	err = tx.QueryRow("SELECT odds_a, odds_b FROM matches WHERE id=$1", matchID).Scan(&oddsA, &oddsB)
	if err != nil {
		svc.SettleBet(ctx, userID, amount, 0, false, lockRef)
		return false, errors.New("match not found")
	}
	if selection == "TEAM_A" {
		odds = oddsA
	} else {
		odds = oddsB
	}

	potentialWin := amount * odds
	_, err = tx.Exec(
		"INSERT INTO bets (user_id, match_id, selection, amount, odds, potential_win, status) VALUES ($1, $2, $3, $4, $5, $6, 'PENDING')",
		userID, matchID, selection, amount, odds, potentialWin,
	)
	if err != nil {
		svc.SettleBet(ctx, userID, amount, 0, false, lockRef)
		return false, errors.New("failed to place bet")
	}

	if err := tx.Commit(); err != nil {
		svc.SettleBet(ctx, userID, amount, 0, false, lockRef)
		return false, errors.New("commit failed")
	}

	return true, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	userID, ok := UserIDFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	var user model.User
	err := db.DB.QueryRow("SELECT id, username, email, mobile, COALESCE(kyc_level, 0) FROM users WHERE id=$1", userID).Scan(
		&user.ID, &user.Username, &user.Email, &user.Mobile, &user.KycLevel,
	)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// Balance is the resolver for the balance field.
func (r *queryResolver) Balance(ctx context.Context) (*model.Wallet, error) {
	userID, ok := UserIDFromContext(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	svc := wallet.NewService(db.DB, db.RDB)
	w, err := svc.Get(ctx, userID)
	if err != nil {
		return nil, err
	}
	return &model.Wallet{
		ID:       w.ID,
		Balance:  w.DepositBalance + w.BonusBalance + w.WinningsBalance - w.LockedBalance,
		Currency: w.Currency,
		Bonus:    w.BonusBalance,
	}, nil
}

// Matches is the resolver for the matches field.
func (r *queryResolver) Matches(ctx context.Context) ([]*model.Match, error) {
	rows, err := db.DB.Query("SELECT id, team_a, team_b, start_time, status, odds_a, odds_b FROM matches")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var matches []*model.Match
	for rows.Next() {
		var m model.Match
		var t time.Time
		// We don't have odds_draw in DB yet, so we'll skip it or set to 0
		rows.Scan(&m.ID, &m.TeamA, &m.TeamB, &t, &m.Status, &m.OddsTeamA, &m.OddsTeamB)
		m.StartTime = t.String()
		m.OddsDraw = 0 // Default
		matches = append(matches, &m)
	}
	return matches, nil
}

// Match is the resolver for the match field.
func (r *queryResolver) Match(ctx context.Context, id string) (*model.Match, error) {
	var m model.Match
	var t time.Time
	err := db.DB.QueryRow("SELECT id, team_a, team_b, start_time, status, odds_a, odds_b FROM matches WHERE id=$1", id).
		Scan(&m.ID, &m.TeamA, &m.TeamB, &t, &m.Status, &m.OddsTeamA, &m.OddsTeamB)
	if err != nil {
		return nil, err
	}
	m.StartTime = t.String()
	m.OddsDraw = 0
	return &m, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// User returns UserResolver implementation.
func (r *Resolver) User() UserResolver { return &userResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type userResolver struct{ *Resolver }

// Wallet resolves the wallet field for a user.
func (r *userResolver) Wallet(ctx context.Context, obj *model.User) (*model.Wallet, error) {
	userID := obj.ID
	if userID == "" {
		var ok bool
		userID, ok = UserIDFromContext(ctx)
		if !ok {
			return nil, errors.New("unauthorized")
		}
	}

	svc := wallet.NewService(db.DB, db.RDB)
	w, err := svc.Get(ctx, userID)
	if err != nil {
		return nil, err
	}

	return &model.Wallet{
		ID:       w.ID,
		Balance:  w.DepositBalance + w.BonusBalance + w.WinningsBalance - w.LockedBalance,
		Currency: w.Currency,
		Bonus:    w.BonusBalance,
	}, nil
}
